 [Do OS abstractions make sense on FPGAs?](https://www.usenix.org/conference/osdi20/presentation/roscoe)



FPGA as the hardware accelerators specially designed for certain tasks.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115130819.png)





![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115131321.png)

FPGA is more like a micro-computer with everything.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115131658.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115131724.png)



**The related work section of this work is** **pretty good** - many previous work improve the primitives of FPGA programming.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115132029.png)



Like kernel space and user space isolation design.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115132216.png)

For performance, you still need to choose when to offload compuation to FPGA - for good reasons.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115132435.png)

Portability achieved by (Section 3.3)

- Laguange features

- Address translation - can be translated by the OS during the execution.

- Some other functionalities achievable by the OS.

  

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115132902.png)

Why it's hard to achieve multiplexing - NO hardware interrupt. 

FPGA logic may be **reconfigured**.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115133109.png)



![](https://raw.githubusercontent.com/byshen/picrepo/master/image-20210115133216214.png)





Processes as isolated circuits (vFPGA) at runtime.

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115133431.png)



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115133517.png)

FPGA is IO-rich, more than simply computations. (Different compared to GPUs).

The design of the generic user logic interface, just like ABIs. These calls are achiveable by [AXI4](https://developer.arm.com/documentation/ihi0051/a/Introduction/About-the-AXI4-Stream-protocol) streaming protocol.

CPUs submit both compuation and environment to the vFPGAs. If 

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115133714.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115134002.png)

**Previous can only have run-to-completion scheduling. Because FPGA is not preemptive.** (kind of hard to believe.)

This is still important if you want to have FPGAs on the cloud. Even though coyote's approach is one small step forward though...



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115134208.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115134346.png)

- Pointer swizzling is like previous approaches that change pointers to relative distances...

- They don't like IOMMUs because they are fixed sizes.
- Coyote incorporate the DDR4 on FPGA to dirrectly map that to the address to the CPUs - but this is not coherent though (require driver code to implement cache coherent algorithms.)
- A two-tier TLB, one for large page, one for small page.

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115134902.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135151.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135213.png)

![image-20210115135311031](/Users/byshen/Library/Application Support/typora-user-images/image-20210115135311031.png)

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135348.png)

Not everything is satisfying, but at least thumbs up for many aspects.





![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135548.png)

Evaluation - kind of making sense but with certain overhead.

**Quick takeways.**

![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135740.png)

The argument is that main overhead is the space. The underlying point is that FPGA is not built to share, only one job at a time. So you may have more space though.





![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115135922.png)

context switch which is the reconfiguration time.



![](https://raw.githubusercontent.com/byshen/picrepo/master/20210115140003.png)

Minimizing the number of reconfigurations (context switches).



More micro benchmarks are in the paper.



**Open question:** We try to make FPGA like standard server, but is this the right thing to do? 

